"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = require("vscode");
const fs = require("fs");
const path = require("path");
class ProtoReferencesProvider {
    constructor() {
        this.codeLenses = [];
        this._onDidChangeCodeLenses = new vscode.EventEmitter();
        this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
        this.workspaceIndex = {
            protoFiles: new Map(),
            messageToProto: new Map(),
        };
        // 匹配 Go 代码中的结构体定义
        this.regex = /type\s+(\w+)\s+struct\s*\{/g;
        this.buildWorkspaceIndex();
    }
    async buildWorkspaceIndex() {
        const outputChannel = vscode.window.createOutputChannel("Proto Reference");
        outputChannel.appendLine("Building workspace index...");
        // 清空现有索引
        this.workspaceIndex.protoFiles.clear();
        this.workspaceIndex.messageToProto.clear();
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            return;
        }
        // 查找所有 proto 文件
        for (const folder of workspaceFolders) {
            const protoFiles = await vscode.workspace.findFiles(new vscode.RelativePattern(folder, "**/*.proto"), "**/node_modules/**");
            for (const protoFile of protoFiles) {
                const protoInfo = this.parseProtoFile(protoFile.fsPath);
                this.workspaceIndex.protoFiles.set(protoFile.fsPath, protoInfo);
                // 为每个 message 建立索引
                for (const message of protoInfo.messages) {
                    this.workspaceIndex.messageToProto.set(message.name, message);
                }
            }
        }
        outputChannel.appendLine(`Indexed ${this.workspaceIndex.protoFiles.size} proto files`);
        outputChannel.appendLine(`Indexed ${this.workspaceIndex.messageToProto.size} messages`);
    }
    findProtoSourceFromGoFile(document) {
        const text = document.getText();
        // 匹配 protoc 生成的注释格式
        const lines = text.split("\n");
        let protoPath;
        for (let i = 0; i < Math.min(10, lines.length); i++) {
            const line = lines[i];
            if (line.includes("Code generated by protoc-gen-go")) {
                // 在接下来的几行中查找 source: 注释
                for (let j = i; j < Math.min(i + 5, lines.length); j++) {
                    const sourceLine = lines[j];
                    const sourceMatch = sourceLine.match(/\/\/\s*source:\s*(.+\.proto)/);
                    if (sourceMatch) {
                        protoPath = sourceMatch[1];
                        break;
                    }
                }
                break;
            }
        }
        if (!protoPath) {
            return undefined;
        }
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            return undefined;
        }
        // 首先尝试从当前 Go 文件所在目录开始查找
        const goFileDir = path.dirname(document.uri.fsPath);
        const protoFromGoDir = path.resolve(goFileDir, protoPath);
        if (fs.existsSync(protoFromGoDir)) {
            return protoFromGoDir;
        }
        // 如果从 Go 文件目录找不到，尝试从每个工作区根目录查找
        for (const folder of workspaceFolders) {
            const fullPath = path.join(folder.uri.fsPath, protoPath);
            if (fs.existsSync(fullPath)) {
                return fullPath;
            }
        }
        return undefined;
    }
    parseProtoFile(filePath) {
        if (this.workspaceIndex.protoFiles.has(filePath)) {
            return this.workspaceIndex.protoFiles.get(filePath);
        }
        const content = fs.readFileSync(filePath, "utf8");
        const messages = [];
        const lines = content.split("\n");
        let currentPackage = null;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // 解析 package
            const packageMatch = line.match(/package\s+([.\w]+)/);
            if (packageMatch) {
                currentPackage = packageMatch[1];
                continue;
            }
            // 解析 message
            const messageMatch = line.match(/message\s+(\w+)\s*\{/);
            if (messageMatch) {
                const messageName = messageMatch[1];
                messages.push({
                    name: messageName,
                    line: i,
                    filePath: filePath,
                });
            }
        }
        const info = {
            messages,
            package: currentPackage,
        };
        return info;
    }
    provideCodeLenses(document, token) {
        if (document.languageId !== "go") {
            return [];
        }
        this.codeLenses = [];
        const text = document.getText();
        let matches;
        while ((matches = this.regex.exec(text)) !== null) {
            const line = document.lineAt(document.positionAt(matches.index).line);
            const indexOf = line.text.indexOf(matches[0]);
            const position = new vscode.Position(line.lineNumber, indexOf);
            const range = document.getWordRangeAtPosition(position, /\w+/);
            if (range) {
                const goStructName = matches[1];
                this.codeLenses.push(new vscode.CodeLens(range, {
                    title: "Find Proto Definition",
                    command: "vscode-proto-extension.jumpToProto",
                    arguments: [goStructName],
                }));
            }
        }
        return this.codeLenses;
    }
    async searchInProtoFiles(structName) {
        const outputChannel = vscode.window.createOutputChannel("Proto Reference");
        outputChannel.show();
        outputChannel.appendLine(`Searching for Go struct: ${structName}`);
        // 首先从索引中查找
        const messageInfo = this.workspaceIndex.messageToProto.get(structName);
        if (messageInfo) {
            outputChannel.appendLine(`Found message in index: ${messageInfo.filePath}`);
            const document = await vscode.workspace.openTextDocument(messageInfo.filePath);
            const position = new vscode.Position(messageInfo.line, 0);
            return new vscode.Location(vscode.Uri.file(messageInfo.filePath), position);
        }
        // 如果索引中找不到，尝试从当前文件的注释中查找
        const activeEditor = vscode.window.activeTextEditor;
        if (!activeEditor) {
            return undefined;
        }
        const protoFilePath = this.findProtoSourceFromGoFile(activeEditor.document);
        if (!protoFilePath) {
            outputChannel.appendLine("Could not find proto source file from Go file comments");
            return undefined;
        }
        outputChannel.appendLine(`Found proto file: ${protoFilePath}`);
        const protoInfo = this.parseProtoFile(protoFilePath);
        for (const message of protoInfo.messages) {
            if (message.name === structName) {
                outputChannel.appendLine(`Found message in ${protoFilePath}: ${message.name}`);
                const document = await vscode.workspace.openTextDocument(protoFilePath);
                const position = new vscode.Position(message.line, 0);
                return new vscode.Location(vscode.Uri.file(protoFilePath), position);
            }
        }
        outputChannel.appendLine("No matching message found in proto file");
        return undefined;
    }
    // 重建索引的公共方法
    async rebuildIndex() {
        await this.buildWorkspaceIndex();
    }
}
function activate(context) {
    // 检查是否需要重启
    const shouldRestart = context.globalState.get("proto-extension-needs-restart");
    if (shouldRestart) {
        vscode.window
            .showInformationMessage("Proto Reference 扩展已更新，需要重启 VSCode 窗口以应用更改。是否现在重启？", "重启", "稍后")
            .then((selection) => {
            if (selection === "重启") {
                vscode.commands.executeCommand("workbench.action.reloadWindow");
            }
        });
        // 清除重启标记
        context.globalState.update("proto-extension-needs-restart", false);
    }
    const codelensProvider = new ProtoReferencesProvider();
    // 注册文件系统变化监听器
    const watcher = vscode.workspace.createFileSystemWatcher("**/*.proto");
    context.subscriptions.push(watcher.onDidChange(() => codelensProvider.rebuildIndex()), watcher.onDidCreate(() => codelensProvider.rebuildIndex()), watcher.onDidDelete(() => codelensProvider.rebuildIndex()));
    context.subscriptions.push(vscode.languages.registerCodeLensProvider({ language: "go", scheme: "file" }, codelensProvider));
    context.subscriptions.push(vscode.commands.registerCommand("vscode-proto-extension.jumpToProto", async (structName) => {
        const location = await codelensProvider.searchInProtoFiles(structName);
        if (location) {
            await vscode.window.showTextDocument(location.uri, {
                selection: new vscode.Range(location.range.start, location.range.end),
            });
        }
        else {
            vscode.window.showWarningMessage(`No proto definition found for ${structName}`);
        }
    }));
}
function deactivate() {
    // 设置重启标记
    const context = vscode.extensions.getExtension("vscode-proto-extension")?.exports;
    if (context) {
        context.globalState.update("proto-extension-needs-restart", true);
    }
}
//# sourceMappingURL=extension.js.map