import * as vscode from "vscode";
import * as fs from "fs";
import * as path from "path";

interface MessageInfo {
  name: string;
  line: number;
  filePath: string;
}

interface ProtoFileInfo {
  messages: MessageInfo[];
  package: string | null;
}

interface WorkspaceIndex {
  protoFiles: Map<string, ProtoFileInfo>; // proto 文件路径 -> 文件信息
  messageToProto: Map<string, MessageInfo>; // message 名称 -> message 信息
}

class ProtoReferencesProvider implements vscode.CodeLensProvider {
  private codeLenses: vscode.CodeLens[] = [];
  private regex: RegExp;
  private _onDidChangeCodeLenses: vscode.EventEmitter<void> =
    new vscode.EventEmitter<void>();
  public readonly onDidChangeCodeLenses: vscode.Event<void> =
    this._onDidChangeCodeLenses.event;
  private workspaceIndex: WorkspaceIndex = {
    protoFiles: new Map(),
    messageToProto: new Map(),
  };

  constructor() {
    // 匹配 Go 代码中的结构体定义
    this.regex = /type\s+(\w+)\s+struct\s*\{/g;
    this.buildWorkspaceIndex();
  }

  private async buildWorkspaceIndex() {
    const outputChannel = vscode.window.createOutputChannel("Proto Reference");
    outputChannel.appendLine("Building workspace index...");

    // 清空现有索引
    this.workspaceIndex.protoFiles.clear();
    this.workspaceIndex.messageToProto.clear();

    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return;
    }

    // 查找所有 proto 文件
    for (const folder of workspaceFolders) {
      const protoFiles = await vscode.workspace.findFiles(
        new vscode.RelativePattern(folder, "**/*.proto"),
        "**/node_modules/**"
      );

      for (const protoFile of protoFiles) {
        const protoInfo = this.parseProtoFile(protoFile.fsPath);
        this.workspaceIndex.protoFiles.set(protoFile.fsPath, protoInfo);

        // 为每个 message 建立索引
        for (const message of protoInfo.messages) {
          this.workspaceIndex.messageToProto.set(message.name, message);
        }
      }
    }

    outputChannel.appendLine(
      `Indexed ${this.workspaceIndex.protoFiles.size} proto files`
    );
    outputChannel.appendLine(
      `Indexed ${this.workspaceIndex.messageToProto.size} messages`
    );
  }

  private findProtoSourceFromGoFile(
    document: vscode.TextDocument
  ): string | undefined {
    const text = document.getText();
    // 匹配 protoc 生成的注释格式
    const lines = text.split("\n");
    let protoPath: string | undefined;

    for (let i = 0; i < Math.min(10, lines.length); i++) {
      const line = lines[i];
      if (line.includes("Code generated by protoc-gen-go")) {
        // 在接下来的几行中查找 source: 注释
        for (let j = i; j < Math.min(i + 5, lines.length); j++) {
          const sourceLine = lines[j];
          const sourceMatch = sourceLine.match(/\/\/\s*source:\s*(.+\.proto)/);
          if (sourceMatch) {
            protoPath = sourceMatch[1];
            break;
          }
        }
        break;
      }
    }

    if (!protoPath) {
      return undefined;
    }

    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return undefined;
    }

    // 首先尝试从当前 Go 文件所在目录开始查找
    const goFileDir = path.dirname(document.uri.fsPath);
    const protoFromGoDir = path.resolve(goFileDir, protoPath);
    if (fs.existsSync(protoFromGoDir)) {
      return protoFromGoDir;
    }

    // 如果从 Go 文件目录找不到，尝试从每个工作区根目录查找
    for (const folder of workspaceFolders) {
      const fullPath = path.join(folder.uri.fsPath, protoPath);
      if (fs.existsSync(fullPath)) {
        return fullPath;
      }
    }

    return undefined;
  }

  private parseProtoFile(filePath: string): ProtoFileInfo {
    if (this.workspaceIndex.protoFiles.has(filePath)) {
      return this.workspaceIndex.protoFiles.get(filePath)!;
    }

    const content = fs.readFileSync(filePath, "utf8");
    const messages: MessageInfo[] = [];
    const lines = content.split("\n");
    let currentPackage: string | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      // 解析 package
      const packageMatch = line.match(/package\s+([.\w]+)/);
      if (packageMatch) {
        currentPackage = packageMatch[1];
        continue;
      }

      // 解析 message
      const messageMatch = line.match(/message\s+(\w+)\s*\{/);
      if (messageMatch) {
        const messageName = messageMatch[1];
        messages.push({
          name: messageName,
          line: i,
          filePath: filePath,
        });
      }
    }

    const info: ProtoFileInfo = {
      messages,
      package: currentPackage,
    };

    return info;
  }

  public provideCodeLenses(
    document: vscode.TextDocument,
    token: vscode.CancellationToken
  ): vscode.CodeLens[] | Thenable<vscode.CodeLens[]> {
    if (document.languageId !== "go") {
      return [];
    }

    this.codeLenses = [];
    const text = document.getText();
    let matches;

    while ((matches = this.regex.exec(text)) !== null) {
      const line = document.lineAt(document.positionAt(matches.index).line);
      const indexOf = line.text.indexOf(matches[0]);
      const position = new vscode.Position(line.lineNumber, indexOf);
      const range = document.getWordRangeAtPosition(position, /\w+/);

      if (range) {
        const goStructName = matches[1];
        this.codeLenses.push(
          new vscode.CodeLens(range, {
            title: "Find Proto Definition",
            command: "vscode-proto-extension.jumpToProto",
            arguments: [goStructName],
          })
        );
      }
    }
    return this.codeLenses;
  }

  public async searchInProtoFiles(
    structName: string
  ): Promise<vscode.Location | undefined> {
    const outputChannel = vscode.window.createOutputChannel("Proto Reference");
    outputChannel.show();
    outputChannel.appendLine(`Searching for Go struct: ${structName}`);

    // 首先从索引中查找
    const messageInfo = this.workspaceIndex.messageToProto.get(structName);
    if (messageInfo) {
      outputChannel.appendLine(
        `Found message in index: ${messageInfo.filePath}`
      );
      const document = await vscode.workspace.openTextDocument(
        messageInfo.filePath
      );
      const position = new vscode.Position(messageInfo.line, 0);
      return new vscode.Location(
        vscode.Uri.file(messageInfo.filePath),
        position
      );
    }

    // 如果索引中找不到，尝试从当前文件的注释中查找
    const activeEditor = vscode.window.activeTextEditor;
    if (!activeEditor) {
      return undefined;
    }

    const protoFilePath = this.findProtoSourceFromGoFile(activeEditor.document);
    if (!protoFilePath) {
      outputChannel.appendLine(
        "Could not find proto source file from Go file comments"
      );
      return undefined;
    }

    outputChannel.appendLine(`Found proto file: ${protoFilePath}`);
    const protoInfo = this.parseProtoFile(protoFilePath);

    for (const message of protoInfo.messages) {
      if (message.name === structName) {
        outputChannel.appendLine(
          `Found message in ${protoFilePath}: ${message.name}`
        );
        const document = await vscode.workspace.openTextDocument(protoFilePath);
        const position = new vscode.Position(message.line, 0);
        return new vscode.Location(vscode.Uri.file(protoFilePath), position);
      }
    }

    outputChannel.appendLine("No matching message found in proto file");
    return undefined;
  }

  // 重建索引的公共方法
  public async rebuildIndex() {
    await this.buildWorkspaceIndex();
  }
}

export function activate(context: vscode.ExtensionContext) {
  // 检查是否需要重启
  const shouldRestart = context.globalState.get<boolean>(
    "proto-extension-needs-restart"
  );
  if (shouldRestart) {
    vscode.window
      .showInformationMessage(
        "Proto Reference 扩展已更新，需要重启 VSCode 窗口以应用更改。是否现在重启？",
        "重启",
        "稍后"
      )
      .then((selection) => {
        if (selection === "重启") {
          vscode.commands.executeCommand("workbench.action.reloadWindow");
        }
      });
    // 清除重启标记
    context.globalState.update("proto-extension-needs-restart", false);
  }

  const codelensProvider = new ProtoReferencesProvider();

  // 注册文件系统变化监听器
  const watcher = vscode.workspace.createFileSystemWatcher("**/*.proto");
  context.subscriptions.push(
    watcher.onDidChange(() => codelensProvider.rebuildIndex()),
    watcher.onDidCreate(() => codelensProvider.rebuildIndex()),
    watcher.onDidDelete(() => codelensProvider.rebuildIndex())
  );

  context.subscriptions.push(
    vscode.languages.registerCodeLensProvider(
      { language: "go", scheme: "file" },
      codelensProvider
    )
  );

  context.subscriptions.push(
    vscode.commands.registerCommand(
      "vscode-proto-extension.jumpToProto",
      async (structName: string) => {
        const location = await codelensProvider.searchInProtoFiles(structName);
        if (location) {
          await vscode.window.showTextDocument(location.uri, {
            selection: new vscode.Range(
              location.range.start,
              location.range.end
            ),
          });
        } else {
          vscode.window.showWarningMessage(
            `No proto definition found for ${structName}`
          );
        }
      }
    )
  );
}

export function deactivate() {
  // 设置重启标记
  const context = vscode.extensions.getExtension(
    "vscode-proto-extension"
  )?.exports;
  if (context) {
    context.globalState.update("proto-extension-needs-restart", true);
  }
}
